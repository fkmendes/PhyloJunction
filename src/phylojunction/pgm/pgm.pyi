from __future__ import annotations
import typing as ty
import abc
import matplotlib.pyplot as plt # type: ignore
import numpy as np
from _typeshed import Incomplete
from abc import ABC, abstractmethod


R = ty.TypeVar('R')
def abstract_attribute(obj: ty.Callable[[ty.Any], R] = None) -> R: ...

class DirectedAcyclicGraph:
    node_val_dict: ty.Dict[NodeDAG, ty.Any]
    name_node_dict: ty.Dict[str, NodeDAG]
    n_nodes: int
    sample_size: int
    _random_seed: int
    def __init__(self) -> None: ...
    @property
    def random_seed(self) -> int: ...
    @random_seed.setter
    def random_seed(self, a_seed: int) -> None: ...
    def add_node(self, node_dag: NodeDAG) -> None: ...
    def get_node_dag_by_name(self, node_name): ...
    def get_display_str_by_name(self, node_name, sample_idx=None, repl_size=1): ...
    def get_sorted_node_dag_list(self) -> ty.List[NodeDAG]: ...

class ValueGenerator(ABC, metaclass=abc.ABCMeta):
    @abstract_attribute
    def n_samples(self): ...
    @abstract_attribute
    def n_repl(self): ...
    @abstractmethod
    def __init__(self) -> None: ...
    @abstractmethod
    def generate(self) -> ty.List[ty.Any]: ...
    @abstractmethod
    def init_check_vectorize_sample_size(self, param_list: ty.List[ty.Any]=[]) -> ty.Optional[ty.List[ty.List[ty.Union[int, float, str]]]]: ...
    @abstractmethod
    def get_rev_inference_spec_info(self) -> ty.List[str]: ...

class DistrForSampling(ValueGenerator):
    @property
    @abstractmethod
    def DN_NAME(self) -> str: ...

class ConstantFn(ValueGenerator):
    @property
    @abstractmethod
    def CT_FN_NAME(self) -> str: ...

class NodeDAG(ABC):
    node_name: str
    _value: ty.List[ty.Any]
    _sample_size: int
    _repl_size: int
    call_order_idx: int
    is_sampled: bool
    is_deterministic: bool
    is_clamped: bool
    parent_nd_list: ty.Optional[ty.List[NodeDAG]]
    @property
    def value(self): ...
    @value.setter
    def value(self, a_value): ...
    @property
    def sample_size(self): ...
    @property
    def repl_size(self): ...
    
    @abstractmethod
    def __init__(self, node_name: str, sample_size: ty.Optional[int], replicate_size: int=1, value: ty.Optional[ty.List[ty.Any]]=None, call_order_idx: ty.Optional[int] = None, sampled: bool = False, deterministic: bool=False, clamped: bool=False, parent_nodes: ty.Optional[ty.List[NodeDAG]]=None): ...
    def _flatten_and_extract_values(self) -> None: ...
    def get_start2end_str(self, start: int, end: int, repl_idx: int=0, is_tree: bool=False) -> str: ...
    def __str__(self) -> str: ...
    def __hash__(self): ...
    def __eq__(self, other) -> bool: ...
    def __lt__(self, other) -> bool: ...
    def __len__(self) -> int: ...
    
    @abstractmethod
    def plot_node(self, axes: plt.Axes, sample_idx: int = 0, repl_idx: int = 0, repl_size: int = 1, branch_attr: ty.Optional[str] = "state") -> None: ...

    @abstractmethod
    def populate_operator_weight(self) -> None: ...

    @abstractmethod
    def get_node_stats_str(self, start: int, end: int, repl_idx: int) -> str: ...

class StochasticNodeDAG(NodeDAG):
    sampling_dn: ty.Optional[DistrForSampling]
    constant_fn: ty.Optional[ConstantFn]
    operator_weight: float
    def __init__(self, node_name: str, sample_size: int, sampled_from: ty.Optional[DistrForSampling]=None, returned_from: ty.Optional[ConstantFn]=None, value: ty.Optional[ty.List[ty.Any]]=None, replicate_size: int=1, call_order_idx: ty.Optional[int]=None, deterministic: bool=False, clamped: bool=False, parent_nodes: ty.Optional[ty.List[ty.Any]]=None): ...
    def generate_value(self) -> ty.List[ty.Any]: ...
    def __str__(self) -> str: ...
    def __lt__(self, other): ...
    def plot_node(self, axes: plt.Axes, sample_idx: int=0, repl_idx: int=0, repl_size: int=1, branch_attr: str="state") -> None: ...
    def populate_operator_weight(self) -> None: ...
    def get_node_stats_str(self, start: int, end: int, repl_idx: int) -> str: ...
    
class DeterministicNodeDAG(NodeDAG):
    def __init__(self, node_name: str, value: ty.Optional[ty.List[ty.Any]]=None, call_order_idx: ty.Optional[int]=None, deterministic: bool=True, parent_nodes: ty.Optional[ty.List[NodeDAG]]=None) -> None: ...
    def __str__(self) -> str: ...
    def __lt__(self, other) -> bool: ...
    def __len__(self) -> int: ...
    def plot_node(self, axes: plt.Axes, sample_idx: ty.Optional[int]=0, repl_idx: ty.Optional[int]=0, repl_size: ty.Optional[int]=1, branch_attr: ty.Optional[str]="state") -> None: ...
    def populate_operator_weight(self) -> None: ...
    def get_node_stats_str(self, start: int, end: int, repl_idx: int) -> str: ...

def plot_node_histogram(axes: plt.Axes, values_list: ty.List[float], sample_idx: ty.Optional[int]=None, repl_size: int=1) -> None: ...
def plot_blank(axes: plt.Axes) -> None: ...
def extract_vals_as_str_from_node_dag(val_list: ty.List[ty.Union[str, NodeDAG]]) -> ty.List[str]: ...

