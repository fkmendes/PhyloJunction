import numpy as np
import pgm.pgm as pgm
import typing as ty

class DnLogNormal(pgm.DistributionPGM):
    DN_NAME: str
    n_draws: int
    n_repl: int
    vectorized_params: ty.List[ty.List[ty.Union[int, float, str]]]
    param_dict: ty.Dict[str, ty.Union[bool, ty.List[ty.Union[int, float, str]]]]
    parent_node_tracker: ty.Optional[ty.Dict[str, str]]
    @staticmethod
    def draw_ln(n_draws: int, mean_param: float, sd_param: float, scale: float = ..., log_space: bool = ...) -> ty.Union[np.float64, np.ndarray]: ...
    def __init__(self, pars: ty.List[ty.Union[int, ty.List[float], bool]], parent_node_tracker: ty.Optional[ty.Dict[str, str]] = ...) -> None: ...
    def generate(self) -> ty.Optional[ty.List[float]]: ...
    def check_sample_size(self, param_list) -> ty.List[ty.List[ty.Union[int, float, str]]]: ...
    def get_rev_inference_spec_info(self) -> ty.List[str]: ...

class DnNormal(pgm.DistributionPGM):
    DN_NAME: str
    n_draws: int
    n_repl: int
    vectorized_params: ty.List[ty.List[ty.Union[int, float, str]]]
    param_dict: ty.Dict[str, ty.Union[bool, ty.List[ty.Union[int, float, str]]]]
    parent_node_tracker: ty.Optional[ty.Dict[str, str]]
    @staticmethod
    def draw_normal(n_draws: int, mean_param: float, sd_param: float) -> ty.Union[np.float64, np.ndarray]: ...
    def __init__(self, pars: ty.List[ty.Union[int, ty.List[float]]], parent_node_tracker: ty.Optional[ty.Dict[str, str]] = ...) -> None: ...
    def generate(self) -> ty.Optional[ty.List[float]]: ...
    def check_sample_size(self, param_list): ...
    def get_rev_inference_spec_info(self) -> ty.List[str]: ...

class DnExponential(pgm.DistributionPGM):
    DN_NAME: str
    n_draws: int
    n_repl: int
    vectorized_params: ty.List[ty.List[ty.Union[int, float, str]]]
    param_dict: ty.Dict[str, ty.Union[bool, ty.List[ty.Union[int, float, str]]]]
    parent_node_tracker: ty.Optional[ty.Dict[str, str]]
    @staticmethod
    def draw_exp(n_draws: int, scale_or_rate_param: float, rate_parameterization: bool = ...) -> ty.Union[np.float64, np.ndarray]: ...
    def __init__(self, pars: ty.List[ty.Union[int, ty.List[float], bool]], parent_node_tracker: ty.Optional[ty.Dict[str, str]] = ...) -> None: ...
    def generate(self) -> ty.Optional[ty.List[float]]: ...
    def check_sample_size(self, param_list): ...
    def get_rev_inference_spec_info(self) -> ty.List[str]: ...

class DnGamma(pgm.DistributionPGM):
    DN_NAME: str
    n_draws: int
    n_repl: int
    vectorized_params: ty.List[ty.List[ty.Union[int, float, str]]]
    param_dict: ty.Dict[str, ty.Union[bool, ty.List[ty.Union[int, float, str]]]]
    parent_node_tracker: ty.Optional[ty.Dict[str, str]]
    @staticmethod
    def draw_gamma(n_draws: int, shape_param: float, scale_or_rate_param: float, rate_parameterization: bool = ...) -> ty.Union[np.float64, np.ndarray]: ...
    def __init__(self, pars: ty.List[ty.Union[int, ty.List[float], bool]], parent_node_tracker: ty.Optional[ty.Dict[str, str]] = ...) -> None: ...
    def generate(self) -> ty.Optional[ty.List[float]]: ...
    def check_sample_size(self, param_list: ty.List[ty.Any]) -> ty.List[ty.List[ty.Union[int, float, str]]]: ...
    def get_rev_inference_spec_info(self) -> ty.List[str]: ...

class DnUnif(pgm.DistributionPGM):
    DN_NAME: str
    n_draws: int
    n_repl: int
    vectorized_params: ty.List[ty.List[ty.Union[int, float, str]]]
    param_dict: ty.Dict[str, ty.Union[bool, ty.List[ty.Union[int, float, str]]]]
    parent_node_tracker: ty.Optional[ty.Dict[str, str]]
    @staticmethod
    def draw_unif(n_draws: int, min_param: float, max_param: float) -> ty.Union[np.float64, np.ndarray]: ...
    def __init__(self, pars: ty.List[ty.Union[int, ty.List[float]]], parent_node_tracker: ty.Optional[ty.Dict[str, str]] = ...) -> None: ...
    def generate(self) -> ty.Optional[ty.List[float]]: ...
    def check_sample_size(self, param_list: ty.List[ty.Any]) -> ty.List[ty.List[ty.Union[int, float, str]]]: ...
    def get_rev_inference_spec_info(self) -> ty.List[str]: ...
